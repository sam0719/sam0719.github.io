<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‚¡ç¥¨æŠ•è³‡çµ„åˆç³»çµ±</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        .stock-row {
            cursor: pointer;
        }
        .price-up {
            color: #28a745;
        }
        .price-down {
            color: #dc3545;
        }
        .history-table {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        .pagination {
            margin-bottom: 0;
        }
        .stock-summary {
            background-color: #f8f9fa;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 10px;
        }
        .price-change-icon {
            margin-right: 5px;
        }
        .hover-effect:hover {
            background-color: #f8f9fa;
            transition: background-color 0.3s ease;
        }
        .history-container {
            background-color: #fff;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
        }
        .pagination-container {
            border-top: 1px solid #dee2e6;
            padding-top: 10px;
            margin-top: 10px;
        }
        .market-section {
            margin-bottom: 2rem;
        }
        .index-section {
            margin-bottom: 1rem;
            border-left: 3px solid #e9ecef;
            padding-left: 1rem;
        }
        .market-header, .index-header {
            cursor: pointer;
            padding: 0.5rem;
            background-color: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 1rem;
        }
        .market-header:hover, .index-header:hover {
            background-color: #e9ecef;
        }
        .market-header i, .index-header i {
            transition: transform 0.3s ease;
        }
        .market-header.collapsed i, .index-header.collapsed i {
            transform: rotate(-90deg);
        }
    </style>
</head>
<body>
    <div class="container mt-4">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h2 class="mb-0">è‚¡ç¥¨æŠ•è³‡çµ„åˆç³»çµ±</h2>
            <a href="#" class="btn btn-outline-secondary" onclick="history.back(); return false;">
                <i class="fas fa-arrow-left mr-1"></i>è¿”å›ä¸»é 
            </a>
        </div>

        <!-- è‚¡ç¥¨åˆ—è¡¨ -->
        <div class="row">
            <div class="col-12">
                <div id="stock-list-container">
                    <!-- è‚¡ç¥¨åˆ—è¡¨å°‡é€šé JavaScript å‹•æ…‹ç”Ÿæˆ -->
                </div>
            </div>
        </div>

        <!-- ä¸‹è¼‰åŠŸèƒ½ -->
        <div class="row mt-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-download me-1"></i>
                        ä¸‹è¼‰è‚¡åƒ¹è³‡æ–™
                    </div>
                    <div class="card-body">
                        <form id="downloadForm">
                            <div class="row mb-3">
                                <div class="col-md-6">
                                    <label for="start_month" class="form-label">èµ·å§‹æœˆä»½</label>
                                    <input type="month" class="form-control" id="start_month" name="start_month" required>
                                </div>
                                <div class="col-md-6">
                                    <label for="end_month" class="form-label">çµæŸæœˆä»½</label>
                                    <input type="month" class="form-control" id="end_month" name="end_month" required>
                                </div>
                            </div>
                            <div class="row mb-3">
                                <div class="col-md-6">
                                    <label for="train_window_type" class="form-label">è¨“ç·´æœŸé•·åº¦</label>
                                    <select class="form-control" id="train_window_type" name="train_window_type">
                                        <option value="Y">å¹´(Y)</option>
                                        <option value="H">åŠå¹´(H)</option>
                                        <option value="Q">å­£(Q)</option>
                                        <option value="M">æœˆ(M)</option>
                                    </select>
                                </div>
                                <div class="col-md-6">
                                    <label for="test_window_type" class="form-label">æ¸¬è©¦æœŸé•·åº¦</label>
                                    <select class="form-control" id="test_window_type" name="test_window_type">
                                        <option value="Y">å¹´(Y)</option>
                                        <option value="H">åŠå¹´(H)</option>
                                        <option value="Q">å­£(Q)</option>
                                        <option value="M">æœˆ(M)</option>
                                        <option value="H_CROSS">åŠå¹´(H)*è·¨å¹´</option>
                                        <option value="Q_CROSS">å­£(Q)*è·¨å¹´</option>
                                        <option value="M_CROSS">æœˆ(M)*è·¨å¹´</option>
                                    </select>
                                </div>
                            </div>
                            <div class="row mb-3">
                                <div class="col-md-6">
                                    <label class="form-label">é¸æ“‡æŒ‡æ•¸ï¼ˆå¯é¸ï¼‰</label>
                                    <select class="form-select" id="index_select" name="index_select">
                                        <option value="">ä¸é¸æ“‡æŒ‡æ•¸</option>
                                    </select>
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label">é¸æ“‡å€‹è‚¡ï¼ˆå¯å¤šé¸ï¼‰</label>
                                    <select class="form-select" id="stock_select" name="stocks[]" multiple>
                                    </select>
                                </div>
                            </div>
                            <button type="submit" class="btn btn-primary">ä¸‹è¼‰Excel</button>
                        </form>
                    </div>
                </div>
            </div>
        </div>

        <!-- èµ°å‹¢åœ–å€åŸŸ -->
        <div class="row mt-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <div class="d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">è‚¡åƒ¹èµ°å‹¢åœ–</h5>
                            <div class="d-flex align-items-center">
                                <select id="chart-symbol-selector" class="form-control form-control-sm mr-2" multiple>
                                </select>
                                <input type="date" id="start-date" class="form-control form-control-sm mr-2">
                                <input type="date" id="end-date" class="form-control form-control-sm mr-2">
                                <button id="update-chart" class="btn btn-primary btn-sm">æ›´æ–°åœ–è¡¨</button>
                            </div>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="chart-container" style="height: 400px;">
                            <canvas id="trend-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>

    <script>
        // éœæ…‹æ•¸æ“šç®¡ç†å™¨
        const staticDataManager = {
            indexData: null,
            marketInfo: null,
            configData: null,
            indexStocks: {},
            stockDataCache: {},
            allDataCache: {},

            // åˆå§‹åŒ–
            async init() {
                try {
                    this.stockDataCache = {};
                    this.allDataCache = {};
                    await this.loadConfig();
                    await this.loadIndexData();
                    console.log('éœæ…‹æ•¸æ“šç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
                } catch (error) {
                    console.error('éœæ…‹æ•¸æ“šç®¡ç†å™¨åˆå§‹åŒ–å¤±æ•—:', error);
                }
            },

            async loadConfig() {
                try {
                    const response = await fetch('config.json');
                    if (!response.ok) {
                        throw new Error(`ç„¡æ³•è¼‰å…¥ config.json: ${response.status}`);
                    }

                    const data = await response.json();
                    this.configData = data;

                    this.indexStocks = {};
                    this.stockToIndex = {};
                    for (const [indexSymbol, config] of Object.entries(data)) {
                        if (config && Array.isArray(config.stocks)) {
                            this.indexStocks[indexSymbol] = config.stocks;
                            for (const stockSymbol of config.stocks) {
                                if (!this.stockToIndex[stockSymbol]) {
                                    this.stockToIndex[stockSymbol] = indexSymbol;
                                }
                            }
                        }
                    }

                    console.log('é…ç½®æª”æ¡ˆè¼‰å…¥å®Œæˆï¼Œå·²å»ºç«‹æŒ‡æ•¸è‚¡ç¥¨æ˜ å°„');
                } catch (error) {
                    console.warn('è¼‰å…¥ config.json å¤±æ•—ï¼Œå°‡ç„¡æ³•é¡¯ç¤ºæˆä»½è‚¡è³‡è¨Š:', error);
                    this.configData = null;
                    this.indexStocks = {};
                    this.stockToIndex = {};
                }
            },

            // è¼‰å…¥ç´¢å¼•æ•¸æ“š
            async loadIndexData() {
                try {
                    // å˜—è©¦è¼‰å…¥åŒ…å«å¸‚å ´ä¿¡æ¯çš„ç´¢å¼•æ–‡ä»¶
                    let response = await fetch('data/index.json');
                    if (response.ok) {
                        const data = await response.json();
                        this.indexData = data.stockData || data;

                        if (data.marketInfo) {
                            this.marketInfo = data.marketInfo;
                            console.log('è¼‰å…¥äº†åŒ…å«å¸‚å ´ä¿¡æ¯çš„ç´¢å¼•æ–‡ä»¶');
                        } else {
                            this.marketInfo = this.generateDefaultMarketInfo();
                            console.log('ç´¢å¼•æ–‡ä»¶ç¼ºå°‘å¸‚å ´ä¿¡æ¯ï¼Œä½¿ç”¨é è¨­å¸‚å ´æ˜ å°„');
                        }
                    } else {
                        // å¦‚æœæ²’æœ‰å¸‚å ´ä¿¡æ¯æ–‡ä»¶ï¼Œå‰‡è¼‰å…¥åŸå§‹æ–‡ä»¶ä¸¦ä½¿ç”¨é»˜èªå¸‚å ´ä¿¡æ¯
                        response = await fetch('data/index.json');
                        if (!response.ok) {
                            throw new Error('ç„¡æ³•è¼‰å…¥ç´¢å¼•æ–‡ä»¶');
                        }
                        this.indexData = await response.json();

                        // è¨­ç½®é»˜èªå¸‚å ´ä¿¡æ¯
                        this.marketInfo = this.generateDefaultMarketInfo();
                        console.log('è¼‰å…¥äº†åŸå§‹ç´¢å¼•æ–‡ä»¶ï¼Œä½¿ç”¨é»˜èªå¸‚å ´ä¿¡æ¯');
                    }
                } catch (error) {
                    console.error('è¼‰å…¥ç´¢å¼•æ•¸æ“šæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    // è¨­ç½®é»˜èªå€¼
                    this.indexData = {};
                    this.marketInfo = {};
                }
            },

            // ç”Ÿæˆé»˜èªå¸‚å ´ä¿¡æ¯
            generateDefaultMarketInfo() {
                const defaultInfo = {
                    'CAC': { name: 'CAC 40', country: 'æ³•åœ‹', market: 'æ³•åœ‹' },
                    'DJIA': { name: 'é“ç“Šå·¥æ¥­æŒ‡æ•¸', country: 'ç¾åœ‹', market: 'ç¾åœ‹' },
                    'DJIA_20251113': { name: 'é“ç“Šå·¥æ¥­æŒ‡æ•¸ (2025æ›´æ–°)', country: 'ç¾åœ‹', market: 'ç¾åœ‹' },
                    'FTSE': { name: 'å¯Œæ™‚100æŒ‡æ•¸', country: 'è‹±åœ‹', market: 'è‹±åœ‹' },
                    'Nikkei': { name: 'æ—¥ç¶“225æŒ‡æ•¸', country: 'æ—¥æœ¬', market: 'æ—¥æœ¬' },
                    'TSX': { name: 'å¤šå€«å¤šè­‰åˆ¸äº¤æ˜“æ‰€æŒ‡æ•¸', country: 'åŠ æ‹¿å¤§', market: 'åŠ æ‹¿å¤§' }
                };

                // ç‚ºç´¢å¼•æ–‡ä»¶ä¸­çš„æ¯å€‹è‚¡ç¥¨ä»£ç¢¼ç”Ÿæˆå¸‚å ´ä¿¡æ¯
                if (this.indexData) {
                    for (const symbol of Object.keys(this.indexData)) {
                        if (!defaultInfo[symbol]) {
                            defaultInfo[symbol] = {
                                name: symbol,
                                country: 'æœªçŸ¥',
                                market: 'æœªçŸ¥'
                            };
                        }
                    }
                }

                return defaultInfo;
            },

            // ç²å–å¸‚å ´ä¿¡æ¯
            getMarketInfo(symbol) {
                return this.marketInfo && this.marketInfo[symbol]
                    ? this.marketInfo[symbol]
                    : { name: symbol, country: 'æœªçŸ¥', market: 'æœªçŸ¥' };
            },

            // ç²å–æ‰€æœ‰å¸‚å ´çš„çµæ§‹
            getMarketStructure() {
                if (!this.marketInfo) {
                    return {};
                }

                const marketStructure = {};

                // æ ¹æ“šå¸‚å ´ä¿¡æ¯åˆ†çµ„
                for (const [symbol, info] of Object.entries(this.marketInfo)) {
                    const marketName = info.market || 'å…¶ä»–';

                    if (!marketStructure[marketName]) {
                        marketStructure[marketName] = {
                            name: marketName,
                            indices: []
                        };
                    }

                    marketStructure[marketName].indices.push({
                        code: symbol,
                        name: info.name || symbol
                    });
                }

                return marketStructure;
            },

            getStocksForIndex(symbol) {
                if (this.indexStocks && this.indexStocks[symbol]) {
                    return this.indexStocks[symbol];
                }
                return [];
            },

            findIndexForStock(stockSymbol) {
                if (this.stockToIndex && this.stockToIndex[stockSymbol]) {
                    return this.stockToIndex[stockSymbol];
                }

                if (this.indexStocks) {
                    for (const [indexSymbol, stocks] of Object.entries(this.indexStocks)) {
                        if (Array.isArray(stocks) && stocks.includes(stockSymbol)) {
                            if (!this.stockToIndex) {
                                this.stockToIndex = {};
                            }
                            this.stockToIndex[stockSymbol] = indexSymbol;
                            return indexSymbol;
                        }
                    }
                }

                return null;
            },

            resolveStocksForDownload(selectedIndex, selectedStocks) {
                const stockSet = new Set();
                const stockToIndexMap = {};

                if (selectedIndex) {
                    const indexStocks = this.getStocksForIndex(selectedIndex) || [];
                    for (const stock of indexStocks) {
                        stockSet.add(stock);
                        stockToIndexMap[stock] = selectedIndex;
                    }
                }

                if (Array.isArray(selectedStocks)) {
                    for (const stock of selectedStocks) {
                        const trimmed = (stock || '').trim();
                        if (!trimmed) {
                            continue;
                        }
                        const indexSymbol = this.findIndexForStock(trimmed);
                        if (indexSymbol) {
                            stockSet.add(trimmed);
                            stockToIndexMap[trimmed] = indexSymbol;
                        } else {
                            console.warn(`æ‰¾ä¸åˆ°è‚¡ç¥¨ ${trimmed} æ‰€å±¬çš„æŒ‡æ•¸ï¼Œç•¥é`);
                        }
                    }
                }

                return {
                    allStocks: Array.from(stockSet).sort(),
                    stockToIndexMap
                };
            },

            deduplicateMonthlyData(records) {
                if (!Array.isArray(records)) {
                    return [];
                }

                const uniqueMap = new Map();

                for (let i = records.length - 1; i >= 0; i--) {
                    const record = records[i];
                    if (!record || !record.date) {
                        continue;
                    }
                    const key = record.date;
                    if (!uniqueMap.has(key)) {
                        uniqueMap.set(key, record);
                    }
                }

                return Array.from(uniqueMap.values()).reverse();
            },

            getSortedFileList(symbol) {
                if (!this.indexData || !this.indexData[symbol]) {
                    return [];
                }

                const files = Array.isArray(this.indexData[symbol])
                    ? this.indexData[symbol]
                    : [];

                const parseOrder = (filename) => {
                    const match = filename && filename.match(/(\d{4})_(\d{2})/);
                    if (!match) {
                        return 0;
                    }
                    const year = parseInt(match[1], 10);
                    const month = parseInt(match[2], 10);
                    return year * 100 + month;
                };

                return [...files].sort((a, b) => parseOrder(a) - parseOrder(b));
            },

            // è¼‰å…¥è‚¡ç¥¨æˆ–æŒ‡æ•¸æ•¸æ“š
            async loadStockData(symbol, filename, targetStockSymbol = null) {
                const normalizedTarget = targetStockSymbol ? targetStockSymbol.trim() : null;
                const cacheKey = `${symbol}-${filename}-${normalizedTarget || '__DEFAULT__'}`;
                if (this.stockDataCache[cacheKey]) {
                    return this.stockDataCache[cacheKey];
                }

                try {
                    console.log(`é–‹å§‹è¼‰å…¥è‚¡åƒ¹æ•¸æ“š: ${symbol}/${filename}`);
                    const response = await fetch(`data/${symbol}/${filename}`);
                    if (!response.ok) {
                        throw new Error(`ç„¡æ³•è¼‰å…¥CSVæ–‡ä»¶: ${response.status}`);
                    }

                    const csvText = await response.text();
                    console.log(`æˆåŠŸè¼‰å…¥CSVæ–‡ä»¶ï¼Œå…§å®¹é•·åº¦: ${csvText.length}`);

                    // å…ˆä¸ç”¨headerè§£æï¼Œæª¢æŸ¥ç¬¬ä¸€è¡Œæ˜¯å¦ç‚ºè‚¡ç¥¨ä»£ç¢¼
                    const lines = csvText.trim().split('\n');
                    if (lines.length === 0) {
                        console.log('CSVæ–‡ä»¶ç‚ºç©º');
                        return [];
                    }

                    const firstLine = lines[0].trim();
                    console.log(`CSVç¬¬ä¸€è¡Œå…§å®¹: ${firstLine}`);

                    // æª¢æŸ¥æ˜¯å¦ç‚ºå¤šè‚¡çŸ©é™£æ ¼å¼ï¼ˆç¬¬ä¸€è¡ŒåŒ…å«å¤šå€‹è‚¡ç¥¨ä»£ç¢¼ï¼‰
                    const isMultiStock = firstLine.includes(',') &&
                        (firstLine.includes('.PA') || firstLine.includes('AAPL') || firstLine.includes('MSFT') ||
                         firstLine.includes('UNH') || firstLine.includes('JNJ') || firstLine.includes('V'));

                    console.log(`æ˜¯å¦ç‚ºå¤šè‚¡æ ¼å¼: ${isMultiStock}`);

                    if (isMultiStock) {
                        // å¤šè‚¡çŸ©é™£æ ¼å¼
                        console.log('è™•ç†å¤šè‚¡çŸ©é™£æ ¼å¼');
                        const stockSymbols = firstLine.split(',').map(item => item.trim());
                        console.log(`è­˜åˆ¥åˆ°è‚¡ç¥¨ä»£ç¢¼: ${stockSymbols.slice(0, 5).join(', ')}...`); // åªé¡¯ç¤ºå‰5å€‹

                        const collectAll = !normalizedTarget;
                        let targetIndex = 0;

                        if (!collectAll) {
                            targetIndex = stockSymbols.findIndex(symbolCode => symbolCode === normalizedTarget);
                            if (targetIndex === -1) {
                                console.warn(`åœ¨ ${filename} ä¸­æ‰¾ä¸åˆ°è‚¡ç¥¨ ${normalizedTarget}`);
                                this.stockDataCache[cacheKey] = [];
                                return [];
                            }
                        }

                        const stockData = collectAll ? Array.from({ length: stockSymbols.length }, () => []) : [];

                        const dateMatch = filename.match(/(\d{4})_(\d{2})/);
                        const fileYear = dateMatch ? parseInt(dateMatch[1], 10) : 1970;
                        const monthIndex = dateMatch ? parseInt(dateMatch[2], 10) - 1 : 0;
                        const daysInMonth = new Date(fileYear, monthIndex + 1, 0).getDate();
                        console.log(`æå–æœˆä»½: ${fileYear}-${String(monthIndex + 1).padStart(2, '0')}`);

                        for (let i = 1; i < lines.length; i++) {
                            const values = lines[i].split(',');
                            const day = Math.min(i, daysInMonth);
                            const currentDate = new Date(fileYear, monthIndex, day);
                            const isoDate = currentDate.toISOString().slice(0, 10);

                            if (collectAll) {
                                for (let j = 0; j < Math.min(stockSymbols.length, values.length); j++) {
                                    const price = parseFloat(values[j]);

                                    if (!isNaN(price)) {
                                        stockData[j].push({
                                            symbol: stockSymbols[j],
                                            date: isoDate,
                                            price: price
                                        });
                                    }
                                }
                            } else {
                                if (targetIndex < values.length) {
                                    const price = parseFloat(values[targetIndex]);
                                    if (!isNaN(price)) {
                                        stockData.push({
                                            symbol: normalizedTarget,
                                            date: isoDate,
                                            price: price
                                        });
                                    }
                                }
                            }
                        }

                        if (collectAll) {
                            const primarySeries = stockData[0] || [];
                            console.log(`æˆåŠŸè§£æ ${primarySeries.length} æ¢æ•¸æ“š`);
                            this.stockDataCache[cacheKey] = primarySeries;
                            return primarySeries;
                        }

                        console.log(`æˆåŠŸè§£æ ${stockData.length} æ¢ ${normalizedTarget} çš„æ•¸æ“š`);
                        this.stockDataCache[cacheKey] = stockData;
                        return stockData;
                    } else {
                        // å–®è‚¡æ™‚é–“åºåˆ—æ ¼å¼ï¼Œä½¿ç”¨æ¨™æº–CSVè§£æ
                        console.log('è™•ç†å–®è‚¡æ™‚é–“åºåˆ—æ ¼å¼');
                        const results = Papa.parse(csvText, {
                            header: true,
                            dynamicTyping: true,
                            skipEmptyLines: true
                        });

                        console.log(`PapaParse è§£æåˆ° ${results.data.length} è¡Œæ•¸æ“š`);

                        const parsedData = results.data.map(row => ({
                            date: row.Date || row.date || Object.values(row)[0],
                            price: parseFloat(row.Close || row.close || row.Price || row.price || Object.values(row)[1])
                        })).filter(item => item.date && !isNaN(item.price));

                        console.log(`è§£æå¾Œå¾—åˆ° ${parsedData.length} æ¢æœ‰æ•ˆæ•¸æ“š`);
                        this.stockDataCache[cacheKey] = parsedData;
                        return parsedData;
                    }

                } catch (error) {
                    console.error(`è¼‰å…¥ ${filename} å¤±æ•—:`, error);
                    return null;
                }
            },

            // ç²å–æŒ‡æ•¸çš„æ‰€æœ‰æ•¸æ“š
            async getAllIndexData(symbol) {
                if (!this.indexData || !this.indexData[symbol]) {
                    console.log(`æ²’æœ‰æ‰¾åˆ° ${symbol} çš„æ•¸æ“šæ–‡ä»¶`);
                    return [];
                }

                const files = this.getSortedFileList(symbol);
                console.log(`${symbol} æœ‰ ${files.length} å€‹æ•¸æ“šæ–‡ä»¶`);

                const allData = [];

                // åªè¼‰å…¥æœ€è¿‘å¹¾å€‹æ–‡ä»¶ä»¥é¿å…è¼‰å…¥éå¤šæ•¸æ“š
                const recentFiles = files.slice(-10); // åªè¼‰å…¥æœ€è¿‘10å€‹æ–‡ä»¶
                console.log(`å°‡è¼‰å…¥æœ€è¿‘ ${recentFiles.length} å€‹æ–‡ä»¶: ${recentFiles.join(', ')}`);

                for (const file of recentFiles) {
                    console.log(`æ­£åœ¨è¼‰å…¥: ${file}`);
                    const data = await this.loadStockData(symbol, file);
                    if (data && data.length > 0) {
                        console.log(`æˆåŠŸè¼‰å…¥ ${data.length} æ¢æ•¸æ“šå¾ ${file}`);
                        allData.push(...data);
                    } else {
                        console.log(`è¼‰å…¥ ${file} å¤±æ•—æˆ–ç„¡æ•¸æ“š`);
                    }
                }

                console.log(`${symbol} ç¸½å…±è¼‰å…¥ ${allData.length} æ¢æ•¸æ“š`);

                // æŒ‰æ—¥æœŸæ’åº
                allData.sort((a, b) => new Date(a.date) - new Date(b.date));
                return allData;
            },

            async getStockHistory(indexSymbol, stockSymbol) {
                const cacheKey = `${indexSymbol}::${stockSymbol}`;
                if (this.allDataCache[cacheKey]) {
                    return this.allDataCache[cacheKey];
                }

                if (!this.indexData || !this.indexData[indexSymbol]) {
                    console.log(`æ²’æœ‰æ‰¾åˆ° ${indexSymbol} çš„æ•¸æ“šæ–‡ä»¶`);
                    return [];
                }

                const files = this.getSortedFileList(indexSymbol);
                console.log(`${indexSymbol}/${stockSymbol} æœ‰ ${files.length} å€‹æ•¸æ“šæ–‡ä»¶`);

                const allData = [];
                console.log(`å°‡è¼‰å…¥å…¨éƒ¨ ${files.length} å€‹æ–‡ä»¶ä»¥å»ºç«‹å®Œæ•´æ­·å²`);

                for (const file of files) {
                    console.log(`æ­£åœ¨è¼‰å…¥ ${stockSymbol}: ${file}`);
                    const data = await this.loadStockData(indexSymbol, file, stockSymbol);
                    if (data && data.length > 0) {
                        console.log(`æˆåŠŸè¼‰å…¥ ${data.length} æ¢ ${stockSymbol} æ•¸æ“šå¾ ${file}`);
                        allData.push(...data);
                    } else {
                        console.log(`è¼‰å…¥ ${stockSymbol} çš„ ${file} å¤±æ•—æˆ–ç„¡æ•¸æ“š`);
                    }
                }

                allData.sort((a, b) => new Date(a.date) - new Date(b.date));
                this.allDataCache[cacheKey] = allData;
                return allData;
            },

            // éæ¿¾æ—¥æœŸç¯„åœ
            filterDataByDate(data, startDate, endDate) {
                const start = new Date(startDate);
                const end = new Date(endDate);
                return data.filter(item => {
                    const itemDate = new Date(item.date);
                    return itemDate >= start && itemDate <= end;
                });
            },

            // æ ¼å¼åŒ–æ•¸æ“šç‚ºåœ–è¡¨æ ¼å¼
            formatDataForChart(data) {
                return {
                    dates: data.map(item => item.date),
                    prices: data.map(item => item.price)
                };
            }
        };

        function cloneDateToMonthStart(date) {
            return new Date(date.getFullYear(), date.getMonth(), 1);
        }

        function addMonths(date, months) {
            const start = cloneDateToMonthStart(date);
            start.setMonth(start.getMonth() + months);
            return start;
        }

        function getPeriodEnd(startDate, months) {
            const nextStart = addMonths(startDate, months);
            return new Date(nextStart.getFullYear(), nextStart.getMonth(), 0);
        }

        function getTestMonths(type) {
            switch (type) {
                case 'Y':
                    return 12;
                case 'H':
                case 'H_CROSS':
                    return 6;
                case 'Q':
                case 'Q_CROSS':
                    return 3;
                default:
                    return 1;
            }
        }

        function getTrainMonths(type) {
            switch (type) {
                case 'Y':
                    return 12;
                case 'H':
                    return 6;
                case 'Q':
                    return 3;
                default:
                    return 1;
            }
        }

        function computeWindowIntervals(startDate, endDate, trainWindowType, testWindowType) {
            const intervals = [];

            const trainMonths = getTrainMonths(trainWindowType || 'M');
            const slideMonths = getTestMonths((testWindowType || 'M').replace('_CROSS', ''));
            const testMonths = getTestMonths(testWindowType || 'M');
            const isCrossYear = (testWindowType || '').endsWith('_CROSS');

            let currentStart = cloneDateToMonthStart(startDate);
            const normalizedEnd = cloneDateToMonthStart(endDate);

            while (currentStart <= normalizedEnd) {
                const trainEnd = getPeriodEnd(currentStart, trainMonths);
                if (trainEnd > endDate) {
                    break;
                }

                let testRange = null;
                if (testWindowType) {
                    const testStart = isCrossYear
                        ? new Date(currentStart.getFullYear() + 1, currentStart.getMonth(), 1)
                        : addMonths(currentStart, trainMonths);
                    const testEnd = getPeriodEnd(testStart, testMonths);
                    testRange = {
                        start: testStart,
                        end: testEnd
                    };
                }

                intervals.push({
                    train: {
                        start: new Date(currentStart),
                        end: trainEnd
                    },
                    test: testRange
                });

                currentStart = addMonths(currentStart, slideMonths);
            }

            return intervals;
        }

        function groupStocksByIndex(stocks, stockToIndexMap) {
            const grouped = new Map();

            for (const stock of stocks) {
                const indexSymbol = stockToIndexMap[stock] || staticDataManager.findIndexForStock(stock);
                if (!indexSymbol) {
                    console.warn(`è‚¡ç¥¨ ${stock} æ‰¾ä¸åˆ°å°æ‡‰æŒ‡æ•¸ï¼Œç•¥é`);
                    continue;
                }
                if (!grouped.has(indexSymbol)) {
                    grouped.set(indexSymbol, new Set());
                }
                grouped.get(indexSymbol).add(stock);
            }

            return Array.from(grouped.entries())
                .map(([indexSymbol, stockSet]) => ({ indexSymbol, stocks: Array.from(stockSet).sort() }))
                .sort((a, b) => a.indexSymbol.localeCompare(b.indexSymbol));
        }

        async function loadAllDailyData(indexSymbol, stocks) {
            const dayMap = new Map();

            for (const stockSymbol of stocks) {
                const history = await staticDataManager.getStockHistory(indexSymbol, stockSymbol);
                if (!history || history.length === 0) {
                    continue;
                }

                for (const record of history) {
                    const dayKey = (record.date || '').slice(0, 10);
                    if (!dayKey) {
                        continue;
                    }
                    if (!dayMap.has(dayKey)) {
                        dayMap.set(dayKey, {});
                    }
                    dayMap.get(dayKey)[stockSymbol] = record.price;
                }
            }

            return dayMap;
        }

        function formatMonthLabel(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            return `${year}${month}`;
        }

        function formatMonthKey(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            return `${year}-${month}`;
        }

        function buildCsvForInterval(dayMap, stocks, startDate, endDate) {
            const rows = [stocks.join(',')];

            let current = new Date(startDate);
            current.setHours(0, 0, 0, 0);
            const targetEnd = new Date(endDate);
            targetEnd.setHours(0, 0, 0, 0);
            let hasData = false;

            while (current <= targetEnd) {
                const key = current.toISOString().slice(0, 10);
                const prices = dayMap.get(key) || {};
                const row = [];
                let rowHasValue = false;

                for (const stock of stocks) {
                    if (prices[stock] !== undefined) {
                        row.push(prices[stock]);
                        rowHasValue = true;
                    } else {
                        row.push('');
                    }
                }

                if (rowHasValue) {
                    rows.push(row.join(','));
                    hasData = true;
                }

                current.setDate(current.getDate() + 1);
            }

            if (!hasData) {
                return null;
            }

            return rows.join('\n');
        }

        function getQuarter(date) {
            return Math.floor(date.getMonth() / 3) + 1;
        }

        function pad2(value) {
            return String(value).padStart(2, '0');
        }

        function getHalfYearLabel(date) {
            return date.getMonth() < 6 ? 'Q1-Q2' : 'Q3-Q4';
        }

        function formatDateISO(date) {
            return `${date.getFullYear()}-${pad2(date.getMonth() + 1)}-${pad2(date.getDate())}`;
        }

        function formatDateCompact(date) {
            return `${date.getFullYear()}${pad2(date.getMonth() + 1)}${pad2(date.getDate())}`;
        }

        function generateStaticFilename(type, indexSymbol, interval, windowType, testWindowType) {
            const range = type === 'train' ? interval.train : interval.test;
            if (!range) {
                return `${indexSymbol}_${type}.csv`;
            }

            const start = range.start;
            const end = range.end;

            const startYear = start.getFullYear();
            const endYear = end.getFullYear();
            const startMonth = start.getMonth() + 1;
            const endMonth = end.getMonth() + 1;
            const startQuarter = getQuarter(start);
            const endQuarter = getQuarter(end);

            const normalizedWindow = (windowType || 'M').toUpperCase();
            const normalizedTest = (testWindowType || 'M').toUpperCase();
            const baseTestType = normalizedTest.replace('_CROSS', '');

            let namePart = null;

            if (normalizedTest.endsWith('_CROSS')) {
                const testPrefix = normalizedTest.split('_')[0];
                if (testPrefix === 'Q') {
                    if (type === 'test') {
                        namePart = `${type}_${startYear}_Q${startQuarter}(${endYear} Q${endQuarter}).csv`;
                    } else {
                        namePart = `${type}_${startYear}_Q${startQuarter}(${startYear} Q${startQuarter}).csv`;
                    }
                } else if (testPrefix === 'H') {
                    const halfLabel = getHalfYearLabel(start);
                    if (type === 'test') {
                        namePart = `${type}_${startYear}_${halfLabel}(${endYear} Q${endQuarter}).csv`;
                    } else {
                        namePart = `${type}_${startYear}_${halfLabel}(${startYear} Q${startQuarter}).csv`;
                    }
                } else { // M_CROSS
                    const monthLabel = pad2(startMonth);
                    if (type === 'test') {
                        namePart = `${type}_${startYear}_${monthLabel}(${endYear} Q${endQuarter}).csv`;
                    } else {
                        namePart = `${type}_${startYear}_${monthLabel}(${startYear} Q${startQuarter}).csv`;
                    }
                }
            } else if (type === 'train') {
                switch (normalizedWindow) {
                    case 'Y':
                        if (baseTestType === 'Y') {
                            namePart = `${type}_${startYear}(${startYear} Q1).csv`;
                        } else if (baseTestType === 'H' || baseTestType === 'Q') {
                            if (startYear === endYear) {
                                namePart = `${type}_${startYear}(${startYear} Q1).csv`;
                            } else {
                                namePart = `${type}_${startYear}_Q${startQuarter}~${endYear}_Q${endQuarter}(${startYear} Q1).csv`;
                            }
                        } else if (baseTestType === 'M') {
                            if (startYear === endYear) {
                                namePart = `${type}_${startYear}(${startYear} Q1).csv`;
                            } else {
                                namePart = `${type}_${startYear}_${pad2(startMonth)}~${endYear}_${pad2(endMonth)}(${startYear} Q1).csv`;
                            }
                        }
                        break;
                    case 'H':
                        if (baseTestType === 'H') {
                            namePart = `${type}_${startYear}_Q${startQuarter}~Q${endQuarter}(${startYear} Q1).csv`;
                        } else if (baseTestType === 'Q') {
                            if (startYear === endYear) {
                                namePart = `${type}_${startYear}_Q${startQuarter}~Q${endQuarter}(${startYear} Q1).csv`;
                            } else {
                                namePart = `${type}_${startYear}_Q${startQuarter}~${endYear}_Q${endQuarter}(${startYear} Q1).csv`;
                            }
                        } else if (baseTestType === 'M') {
                            if (startYear === endYear) {
                                namePart = `${type}_${startYear}_${pad2(startMonth)}-${pad2(endMonth)}(${startYear} Q1).csv`;
                            } else {
                                namePart = `${type}_${startYear}_${pad2(startMonth)}~${endYear}_${pad2(endMonth)}(${startYear} Q1).csv`;
                            }
                        }
                        break;
                    case 'Q':
                        if (baseTestType === 'Q') {
                            namePart = `${type}_${startYear}_Q${startQuarter}(${startYear} Q1).csv`;
                        } else if (baseTestType === 'M') {
                            if (startYear === endYear) {
                                namePart = `${type}_${startYear}_${pad2(startMonth)}-${pad2(endMonth)}(${startYear} Q1).csv`;
                            } else {
                                namePart = `${type}_${startYear}_${pad2(startMonth)}~${endYear}_${pad2(endMonth)}(${startYear} Q1).csv`;
                            }
                        }
                        break;
                    case 'M':
                        if (baseTestType === 'M') {
                            namePart = `${type}_${startYear}_${pad2(startMonth)}(${startYear} Q1).csv`;
                        }
                        break;
                    default:
                        break;
                }
            } else { // type === 'test'
                switch (baseTestType) {
                    case 'Y':
                        namePart = `${type}_${startYear}(${startYear} Q1).csv`;
                        break;
                    case 'H':
                        namePart = `${type}_${startYear}_Q${startQuarter}-Q${endQuarter}(${startYear} Q1).csv`;
                        break;
                    case 'Q':
                        namePart = `${type}_${startYear}_Q${startQuarter}(${startYear} Q1).csv`;
                        break;
                    case 'M':
                        namePart = `${type}_${startYear}_${pad2(startMonth)}(${startYear} Q1).csv`;
                        break;
                    default:
                        break;
                }
            }

            if (!namePart) {
                const startLabel = formatMonthLabel(start);
                const endLabel = formatMonthLabel(end);
                namePart = `${type}_${startLabel}_${endLabel}.csv`;
            }

            return `${indexSymbol}_${namePart}`;
        }

        // å­˜å„²æ¯å€‹è‚¡ç¥¨çš„åœ–è¡¨å¯¦ä¾‹
        const charts = {};
        const colors = [
            'rgb(75, 192, 192)',   // é’ç¶ 
            'rgb(255, 99, 132)',   // ç²‰ç´…
            'rgb(255, 159, 64)',   // æ©™è‰²
            'rgb(153, 102, 255)',  // ç´«è‰²
            'rgb(54, 162, 235)',   // è—è‰²
            'rgb(255, 205, 86)',   // é»ƒè‰²
            'rgb(201, 203, 207)'   // ç°è‰²
        ];

        const HISTORY_PAGE_SIZE = 20;
        const historyDataCache = {};
        const historyPageState = {};
        const loadedIndexStocks = new Set();

        function createSafeId(...parts) {
            return parts
                .filter(Boolean)
                .map(part => String(part).replace(/[^a-zA-Z0-9]/g, '_'))
                .join('__');
        }

        function getHistoryCacheKey(symbol, stockSymbol = null) {
            return stockSymbol ? `${symbol}::${stockSymbol}` : symbol;
        }

        // åˆå§‹åŒ–æ—¥æœŸé¸æ“‡å™¨
        function initializeDatePickers() {
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            const thisMonth = todayStr.slice(0, 7);

            const start = new Date(today);
            start.setFullYear(today.getFullYear() - 1);
            const startDateStr = start.toISOString().split('T')[0];
            const startMonth = startDateStr.slice(0, 7);

            $('#start-date').val(startDateStr);
            $('#end-date').val(todayStr);
            $('#start-date').attr('max', todayStr);
            $('#end-date').attr('max', todayStr);

            $('#start_month').val(startMonth);
            $('#end_month').val(thisMonth);
            $('#start_month').attr('max', thisMonth);
            $('#end_month').attr('max', thisMonth);
            $('#end_month').attr('min', startMonth);
        }

    

        // æ¸²æŸ“è‚¡ç¥¨åˆ—è¡¨ - ä¿æŒåŸæœ¬çš„å¸‚å ´å’ŒæŒ‡æ•¸åˆ†å±¤çµæ§‹
        async function renderStockList() {
            console.log('ğŸ—ï¸ é–‹å§‹æ¸²æŸ“è‚¡ç¥¨åˆ—è¡¨...');
            const container = $('#stock-list-container');
            container.empty();
            loadedIndexStocks.clear();

            const marketStructure = staticDataManager.getMarketStructure();
            console.log('å¸‚å ´çµæ§‹:', marketStructure);

            for (const [marketName, marketData] of Object.entries(marketStructure)) {
                const marketCode = marketName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                console.log(`è™•ç†å¸‚å ´: ${marketName}, ${marketData.indices.length} å€‹æŒ‡æ•¸`);

                let marketHtml = `
                    <div class="market-section">
                        <div class="market-header d-flex justify-content-between align-items-center"
                             data-toggle="collapse"
                             data-target="#market-${marketCode}">
                            <h4 class="mb-0">${marketName}</h4>
                            <i class="fas fa-chevron-down"></i>
                        </div>

                        <div class="collapse show" id="market-${marketCode}">
                `;

                for (const indexData of marketData.indices) {
                    const indexSymbol = indexData.code;
                    const safeIndexId = createSafeId('index', indexSymbol);
                    const summaryId = createSafeId('index-summary', indexSymbol);
                    const files = staticDataManager.indexData && staticDataManager.indexData[indexSymbol] ? staticDataManager.indexData[indexSymbol] : [];
                    const latestFile = files[files.length - 1];
                    const stocks = staticDataManager.getStocksForIndex(indexSymbol);

                    console.log(`è™•ç†æŒ‡æ•¸ ${indexSymbol}: ${files.length} å€‹æ–‡ä»¶, æœ€æ–°æ–‡ä»¶: ${latestFile}, æˆä»½è‚¡ ${stocks.length} æª”`);

                    const stockListHtml = stocks.length === 0
                        ? '<p class="text-muted small mb-0">æœªè¨­å®šæˆä»½è‚¡</p>'
                        : stocks.map(stockSymbol => {
                            const stockId = createSafeId('stock', indexSymbol, stockSymbol);
                            const historyCollapseId = createSafeId('history', indexSymbol, stockSymbol);
                            const priceId = createSafeId('price', indexSymbol, stockSymbol);
                            const changeId = createSafeId('change', indexSymbol, stockSymbol);
                            const tableBodyId = createSafeId('history-data', indexSymbol, stockSymbol);
                            const paginationId = createSafeId('pagination', indexSymbol, stockSymbol);

                            return `
                                <div class="stock-item mb-2">
                                    <div class="row align-items-center stock-row hover-effect"
                                         data-toggle="collapse"
                                         data-target="#${historyCollapseId}"
                                         data-index="${indexSymbol}"
                                         data-stock="${stockSymbol}"
                                         aria-expanded="false">
                                        <div class="col-md-4">
                                            <h6 class="mb-0">${stockSymbol}</h6>
                                            <small class="text-muted">${indexData.name}</small>
                                        </div>
                                        <div class="col-md-3">
                                            <span class="font-weight-bold" id="${priceId}">
                                                <i class="fas fa-spinner fa-spin"></i>
                                            </span>
                                        </div>
                                        <div class="col-md-3">
                                            <span id="${changeId}">
                                                <i class="fas fa-spinner fa-spin"></i>
                                            </span>
                                        </div>
                                        <div class="col-md-2 text-right">
                                            <i class="fas fa-chevron-down"></i>
                                        </div>
                                    </div>

                                    <div class="collapse stock-history-collapse"
                                         id="${historyCollapseId}"
                                         data-index="${indexSymbol}"
                                         data-stock="${stockSymbol}">
                                        <div class="history-container">
                                            <table class="table table-sm history-table">
                                                <thead>
                                                    <tr>
                                                        <th>æ—¥æœŸ</th>
                                                        <th>åƒ¹æ ¼</th>
                                                        <th>æ¼²è·Œ</th>
                                                    </tr>
                                                </thead>
                                                <tbody id="${tableBodyId}">
                                                    <tr>
                                                        <td colspan="3" class="text-center">
                                                            <i class="fas fa-spinner fa-spin"></i> è¼‰å…¥ä¸­...
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                            <div class="pagination-container d-flex justify-content-between align-items-center"
                                                 id="${paginationId}"
                                                 data-index="${indexSymbol}"
                                                 data-stock="${stockSymbol}"
                                                 style="display: none;">
                                                <button class="btn btn-sm btn-outline-secondary pagination-button" data-action="prev" disabled>ä¸Šä¸€é </button>
                                                <span class="pagination-info text-muted">ç¬¬ 1 / 1 é </span>
                                                <button class="btn btn-sm btn-outline-secondary pagination-button" data-action="next" disabled>ä¸‹ä¸€é </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('');

                    const summaryCollapseId = createSafeId('history', indexSymbol);
                    marketHtml += `
                        <div class="index-section">
                            <div class="index-header d-flex justify-content-between align-items-center"
                                 data-toggle="collapse"
                                 data-target="#${safeIndexId}">
                                <h5 class="mb-0">${indexData.name}</h5>
                                <i class="fas fa-chevron-down"></i>
                            </div>

                            <div class="collapse show" id="${safeIndexId}">
                                <div class="stock-summary mb-3">
                                    <div class="row align-items-center stock-row hover-effect"
                                         data-toggle="collapse"
                                         data-target="#${summaryCollapseId}"
                                         aria-expanded="false">
                                        <div class="col-md-4">
                                            <h6 class="mb-0">${indexSymbol}</h6>
                                            <small class="text-muted">${indexData.name}</small>
                                        </div>
                                        <div class="col-md-3">
                                            <span class="font-weight-bold" id="price-${indexSymbol}">
                                                <i class="fas fa-spinner fa-spin"></i>
                                            </span>
                                        </div>
                                        <div class="col-md-3">
                                            <span id="change-${indexSymbol}">
                                                <i class="fas fa-spinner fa-spin"></i>
                                            </span>
                                        </div>
                                        <div class="col-md-2 text-right">
                                            <span class="text-muted">${files.length} å€‹æ•¸æ“šæ–‡ä»¶</span>
                                            <i class="fas fa-chevron-down ml-2"></i>
                                        </div>
                                    </div>

                                    <div class="collapse history-collapse" id="${summaryCollapseId}" data-symbol="${indexSymbol}">
                                        <div class="history-container">
                                            <h6 class="text-muted mb-3">æˆä»½è‚¡ (${stocks.length})</h6>
                                            <div class="stock-list">
                                                ${stockListHtml}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    console.log(`âš ï¸ ${indexSymbol} æ²’æœ‰æ•¸æ“šæ–‡ä»¶`);
                    setTimeout(() => {
                        $(`#price-${indexSymbol}`).text('');
                        $(`#change-${indexSymbol}`).text('');
                    }, 100);
                    

                }

                marketHtml += `
                        </div>
                    </div>
                `;

                container.append(marketHtml);
            }

            container
                .off('show.bs.collapse', '.history-collapse')
                .on('show.bs.collapse', '.history-collapse', async function() {
                    const symbol = $(this).data('symbol');
                    if (symbol) {
                        await loadIndexStocks(symbol);
                    }
                })
                .off('show.bs.collapse', '.stock-history-collapse')
                .on('show.bs.collapse', '.stock-history-collapse', async function() {
                    const indexSymbol = $(this).data('index');
                    const stockSymbol = $(this).data('stock');
                    if (indexSymbol && stockSymbol) {
                        await loadStockHistory(indexSymbol, stockSymbol);
                    }
                })
                .off('click', '.pagination-button')
                .on('click', '.pagination-button', function(event) {
                    event.preventDefault();

                    const $button = $(this);
                    const action = $button.data('action');
                    const $container = $button.closest('.pagination-container');
                    const indexSymbol = $container.data('index');
                    const stockSymbol = $container.data('stock') || null;
                    const cacheKey = getHistoryCacheKey(indexSymbol, stockSymbol);

                    if (!cacheKey || !historyDataCache[cacheKey]) {
                        return;
                    }

                    const totalPages = Math.ceil(historyDataCache[cacheKey].length / HISTORY_PAGE_SIZE) || 1;
                    const currentPage = historyPageState[cacheKey] || 1;
                    let targetPage = currentPage;

                    if (action === 'prev') {
                        targetPage = Math.max(1, currentPage - 1);
                    } else if (action === 'next') {
                        targetPage = Math.min(totalPages, currentPage + 1);
                    }

                    if (targetPage !== currentPage) {
                        renderHistoryPage(indexSymbol, stockSymbol, targetPage);
                    }
                });

            console.log('âœ… è‚¡ç¥¨åˆ—è¡¨æ¸²æŸ“å®Œæˆ');
        }

        async function loadIndexStocks(indexSymbol) {
            if (!indexSymbol) {
                return;
            }

            if (loadedIndexStocks.has(indexSymbol)) {
                return;
            }

            const stocks = staticDataManager.getStocksForIndex(indexSymbol) || [];
            if (stocks.length === 0) {
                loadedIndexStocks.add(indexSymbol);
                return;
            }

            const files = staticDataManager.indexData && staticDataManager.indexData[indexSymbol]
                ? staticDataManager.indexData[indexSymbol]
                : [];
            const latestFile = files.length > 0 ? files[files.length - 1] : null;

            loadedIndexStocks.add(indexSymbol);

            if (!latestFile) {
                stocks.forEach(stockSymbol => {
                    const priceId = createSafeId('price', indexSymbol, stockSymbol);
                    const changeId = createSafeId('change', indexSymbol, stockSymbol);
                    $(`#${priceId}`).text('ç„¡æ•¸æ“š');
                    $(`#${changeId}`).text('-');
                });
                return;
            }

            try {
                await Promise.all(stocks.map(stockSymbol =>
                    loadLatestPrice(indexSymbol, latestFile, stockSymbol)
                ));
            } catch (error) {
                console.error(`è¼‰å…¥ ${indexSymbol} æˆä»½è‚¡æœ€æ–°åƒ¹æ ¼å¤±æ•—:`, error);
                stocks.forEach(stockSymbol => {
                    const priceId = createSafeId('price', indexSymbol, stockSymbol);
                    const changeId = createSafeId('change', indexSymbol, stockSymbol);
                    $(`#${priceId}`).text('è¼‰å…¥å¤±æ•—');
                    $(`#${changeId}`).text('-');
                });
                loadedIndexStocks.delete(indexSymbol);
            }
        }

        async function loadStockHistory(indexSymbol, stockSymbol) {
            if (!indexSymbol || !stockSymbol) {
                return;
            }

            const cacheKey = getHistoryCacheKey(indexSymbol, stockSymbol);
            const tbodyId = createSafeId('history-data', indexSymbol, stockSymbol);
            const paginationId = createSafeId('pagination', indexSymbol, stockSymbol);
            const tbody = $(`#${tbodyId}`);
            const pagination = $(`#${paginationId}`);

            if (!tbody.length) {
                return;
            }

            try {
                if (historyDataCache[cacheKey]) {
                    historyPageState[cacheKey] = 1;
                    renderHistoryPage(indexSymbol, stockSymbol, 1);
                    return;
                }

                const allData = await staticDataManager.getStockHistory(indexSymbol, stockSymbol);
                console.log(`${indexSymbol}/${stockSymbol} æ­·å²æ•¸æ“šè¼‰å…¥å®Œæˆï¼Œå…± ${allData ? allData.length : 0} æ¢è¨˜éŒ„`);

                if (allData && allData.length > 0) {
                    const sortedData = [...allData].sort((a, b) => new Date(b.date) - new Date(a.date));
                    historyDataCache[cacheKey] = sortedData;
                    historyPageState[cacheKey] = 1;
                    renderHistoryPage(indexSymbol, stockSymbol, 1);
                    console.log(`${indexSymbol}/${stockSymbol} æ­·å²æ•¸æ“šè¡¨æ ¼æ›´æ–°å®Œæˆ`);
                } else {
                    tbody.html('<tr><td colspan="3" class="text-center text-muted">ç„¡æ•¸æ“š</td></tr>');
                    pagination.hide();
                }
            } catch (error) {
                console.error(`è¼‰å…¥ ${indexSymbol}/${stockSymbol} æ­·å²æ•¸æ“šå¤±æ•—:`, error);
                tbody.html('<tr><td colspan="3" class="text-center text-danger">è¼‰å…¥å¤±æ•—</td></tr>');
                pagination.hide();
            }
        }

        // è¼‰å…¥æœ€æ–°åƒ¹æ ¼
        async function loadLatestPrice(indexSymbol, filename, stockSymbol = null) {
            const cacheKey = stockSymbol ? `${indexSymbol}-${stockSymbol}` : indexSymbol;
            const priceElementId = stockSymbol
                ? createSafeId('price', indexSymbol, stockSymbol)
                : createSafeId('price', indexSymbol);
            const changeElementId = stockSymbol
                ? createSafeId('change', indexSymbol, stockSymbol)
                : createSafeId('change', indexSymbol);

            console.log(`é–‹å§‹è¼‰å…¥ ${cacheKey} æœ€æ–°åƒ¹æ ¼ï¼Œæ–‡ä»¶: ${filename}`);

            try {
                const data = await staticDataManager.loadStockData(indexSymbol, filename, stockSymbol);
                console.log(`${cacheKey} è¼‰å…¥çµæœ:`, data ? `æˆåŠŸï¼Œ${data.length}æ¢æ•¸æ“š` : 'å¤±æ•—');

                if (data && data.length > 0) {
                    const latest = data[data.length - 1];
                    const previous = data.length > 1 ? data[data.length - 2] : null;

                    console.log(`${cacheKey} æœ€æ–°åƒ¹æ ¼: ${latest.price}, æ—¥æœŸ: ${latest.date}`);

                    const price = latest.price.toFixed(2);
                    let changeHtml = '';

                    if (previous) {
                        const priceChange = latest.price - previous.price;
                        const priceChangePercent = previous.price !== 0 ? (priceChange / previous.price * 100) : 0;
                        const direction = priceChange >= 0 ? 'up' : 'down';
                        const icon = priceChange >= 0 ? 'fa-caret-up' : 'fa-caret-down';

                        changeHtml = `
                            <span class="price-${direction}">
                                <i class="fas ${icon} price-change-icon"></i>
                                ${priceChange.toFixed(2)} (${priceChangePercent.toFixed(2)}%)
                            </span>
                        `;
                    } else {
                        changeHtml = '<span class="text-muted">-</span>';
                    }

                    console.log(`æ›´æ–° ${cacheKey} åƒ¹æ ¼é¡¯ç¤º`);
                    $(`#${priceElementId}`).text(price);
                    $(`#${changeElementId}`).html(changeHtml);
                } else {
                    console.log(`${cacheKey} æ²’æœ‰æ•¸æ“š`);
                    $(`#${priceElementId}`).text('ç„¡æ•¸æ“š');
                    $(`#${changeElementId}`).text('-');
                }
            } catch (error) {
                console.error(`è¼‰å…¥ ${cacheKey} æœ€æ–°åƒ¹æ ¼å¤±æ•—:`, error);
                $(`#${priceElementId}`).text('è¼‰å…¥å¤±æ•—');
                $(`#${changeElementId}`).text('-');
            }
        }

        // è¼‰å…¥æ­·å²æ•¸æ“š
        async function loadHistoryData(symbol) {
            console.log(`é–‹å§‹è¼‰å…¥ ${symbol} æ­·å²æ•¸æ“š`);
            const cacheKey = getHistoryCacheKey(symbol);
            const tbody = $(`#history-data-${symbol}`);
            const pagination = $(`#pagination-${symbol}`);

            if (!tbody.length) {
                return;
            }

            try {
                if (historyDataCache[cacheKey]) {
                    historyPageState[cacheKey] = 1;
                    renderHistoryPage(symbol, null, 1);
                    return;
                }

                const allData = await staticDataManager.getAllIndexData(symbol);
                console.log(`${symbol} æ­·å²æ•¸æ“šè¼‰å…¥å®Œæˆï¼Œå…± ${allData ? allData.length : 0} æ¢è¨˜éŒ„`);

                if (allData && allData.length > 0) {
                    const sortedData = [...allData].sort((a, b) => new Date(b.date) - new Date(a.date));
                    historyDataCache[cacheKey] = sortedData;
                    historyPageState[cacheKey] = 1;
                    renderHistoryPage(symbol, null, 1);
                    console.log(`${symbol} æ­·å²æ•¸æ“šè¡¨æ ¼æ›´æ–°å®Œæˆ`);
                } else {
                    console.log(`${symbol} ç„¡æ­·å²æ•¸æ“š`);
                    tbody.html('<tr><td colspan="3" class="text-center text-muted">ç„¡æ•¸æ“š</td></tr>');
                    pagination.hide();
                }
            } catch (error) {
                console.error(`è¼‰å…¥ ${symbol} æ­·å²æ•¸æ“šå¤±æ•—:`, error);
                tbody.html('<tr><td colspan="3" class="text-center text-danger">è¼‰å…¥å¤±æ•—</td></tr>');
                pagination.hide();
            }
        }

        function renderHistoryPage(indexSymbol, stockSymbol = null, page = 1) {
            const cacheKey = getHistoryCacheKey(indexSymbol, stockSymbol);
            const data = historyDataCache[cacheKey];
            const tbodyId = stockSymbol
                ? createSafeId('history-data', indexSymbol, stockSymbol)
                : `history-data-${indexSymbol}`;
            const paginationId = stockSymbol
                ? createSafeId('pagination', indexSymbol, stockSymbol)
                : `pagination-${indexSymbol}`;
            const tbody = $(`#${tbodyId}`);
            const pagination = $(`#${paginationId}`);

            if (!tbody.length) {
                return;
            }

            if (!data || data.length === 0) {
                tbody.html('<tr><td colspan="3" class="text-center text-muted">ç„¡æ•¸æ“š</td></tr>');
                pagination.hide();
                return;
            }

            const totalPages = Math.ceil(data.length / HISTORY_PAGE_SIZE) || 1;
            const targetPage = Math.max(1, Math.min(page, totalPages));
            historyPageState[cacheKey] = targetPage;

            const startIndex = (targetPage - 1) * HISTORY_PAGE_SIZE;
            const pageData = data.slice(startIndex, startIndex + HISTORY_PAGE_SIZE);

            if (pageData.length === 0) {
                tbody.html('<tr><td colspan="3" class="text-center text-muted">ç„¡æ•¸æ“š</td></tr>');
                pagination.hide();
                return;
            }

            const rowsHtml = pageData.map((record, idx) => {
                const globalIndex = startIndex + idx;
                const previousRecord = data[globalIndex + 1];

                let priceChangeHtml = '-';

                if (previousRecord) {
                    const priceChange = record.price - previousRecord.price;
                    const priceChangePercent = previousRecord.price !== 0
                        ? (priceChange / previousRecord.price * 100)
                        : 0;
                    const direction = priceChange >= 0 ? 'up' : 'down';
                    const icon = priceChange >= 0 ? 'fa-caret-up' : 'fa-caret-down';

                    priceChangeHtml = `
                        <span class="price-${direction}">
                            <i class="fas ${icon} price-change-icon"></i>
                            ${priceChange.toFixed(2)} (${priceChangePercent.toFixed(2)}%)
                        </span>
                    `;
                }

                return `
                    <tr>
                        <td>${record.date}</td>
                        <td>${record.price.toFixed(2)}</td>
                        <td>${priceChangeHtml}</td>
                    </tr>
                `;
            }).join('');

            tbody.html(rowsHtml);

            if (pagination.length > 0) {
                pagination.show();
                pagination.find('.pagination-info').text(`ç¬¬ ${targetPage} / ${totalPages} é `);
                pagination.find('[data-action="prev"]').prop('disabled', targetPage === 1);
                pagination.find('[data-action="next"]').prop('disabled', targetPage === totalPages);

                if (totalPages <= 1) {
                    pagination.hide();
                }
            }
        }

        // åŠ è¼‰å¤šè‚¡ç¥¨èµ°å‹¢åœ–
        async function loadMultiTrendChart() {
            const selectedSymbols = $('#chart-symbol-selector').val();
            const startDate = $('#start-date').val();
            const endDate = $('#end-date').val();

            if (!selectedSymbols || selectedSymbols.length === 0) {
                return;
            }

            // å‰µå»ºä¸€å€‹ Promise æ•¸çµ„ä¾†å­˜å„²æ‰€æœ‰çš„æ•¸æ“šè«‹æ±‚
            const promises = selectedSymbols.map(async symbol => {
                try {
                    const allData = await staticDataManager.getAllIndexData(symbol);
                    const filteredData = staticDataManager.filterDataByDate(allData, startDate, endDate);
                    const chartData = staticDataManager.formatDataForChart(filteredData);

                    return {
                        symbol: symbol,
                        data: chartData
                    };
                } catch (error) {
                    console.error(`Error loading data for ${symbol}:`, error);
                    return null;
                }
            });

            // ç­‰å¾…æ‰€æœ‰è«‹æ±‚å®Œæˆ
            Promise.all(promises).then(results => {
                // éæ¿¾æ‰å¤±æ•—çš„è«‹æ±‚
                results = results.filter(result => result !== null);

                if (results.length === 0) {
                    console.error('No valid data received');
                    return;
                }

                const ctx = document.getElementById('trend-chart').getContext('2d');

                // å¦‚æœåœ–è¡¨å·²å­˜åœ¨ï¼ŒéŠ·æ¯€å®ƒ
                if (charts.trend) {
                    charts.trend.destroy();
                }

                // æº–å‚™æ•¸æ“šé›†
                const datasets = results.map((result, index) => ({
                    label: result.symbol,
                    data: result.data.prices,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length],
                    borderWidth: 2,
                    tension: 0.1,
                    fill: false,
                    pointRadius: 3,
                    pointHoverRadius: 5
                }));

                // å‰µå»ºæ–°åœ–è¡¨
                charts.trend = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: results[0].data.dates,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `è‚¡ç¥¨åƒ¹æ ¼èµ°å‹¢æ¯”è¼ƒ (${startDate} è‡³ ${endDate})`,
                                font: {
                                    size: 16
                                }
                            },
                            tooltip: {
                                enabled: true,
                                callbacks: {
                                    label: function(context) {
                                        return `${context.dataset.label}: $${context.raw.toFixed(2)}`;
                                    }
                                }
                            },
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'æ—¥æœŸ'
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'åƒ¹æ ¼'
                                },
                                beginAtZero: false,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            }).catch(error => {
                console.error('Error loading charts:', error);
            });
        }

        // æ›´æ–°æ¸¬è©¦æœŸé¸é …
        function updateTestWindowOptions() {
            const trainType = $('#train_window_type').val();
            const $testSelect = $('#test_window_type');
            const currentValue = $testSelect.val();

            // æ¸…é™¤ç¾æœ‰é¸é …
            $testSelect.empty();

            // æ·»åŠ åŸºæœ¬é¸é …
            $testSelect.append('<option value="Y">å¹´(Y)</option>');
            $testSelect.append('<option value="H">åŠå¹´(H)</option>');
            $testSelect.append('<option value="Q">å­£(Q)</option>');
            $testSelect.append('<option value="M">æœˆ(M)</option>');

            // æ ¹æ“šè¨“ç·´æœŸé¡å‹æ·»åŠ è·¨å¹´é¸é …
            if (trainType === 'H') {
                $testSelect.append('<option value="H_CROSS">åŠå¹´(H)*è·¨å¹´</option>');
            } else if (trainType === 'Q') {
                $testSelect.append('<option value="Q_CROSS">å­£(Q)*è·¨å¹´</option>');
            } else if (trainType === 'M') {
                $testSelect.append('<option value="M_CROSS">æœˆ(M)*è·¨å¹´</option>');
            }

            // å¦‚æœä¹‹å‰é¸æ“‡çš„å€¼ä»ç„¶å­˜åœ¨ï¼Œå‰‡ä¿æŒé¸ä¸­
            if ($testSelect.find(`option[value="${currentValue}"]`).length > 0) {
                $testSelect.val(currentValue);
            }
        }

        // åˆå§‹åŒ– Select2 å’Œæ—¥æœŸé¸æ“‡å™¨
        $(document).ready(async function() {
            console.log('ğŸš€ é–‹å§‹åˆå§‹åŒ–æ‡‰ç”¨ç¨‹åº...');

            // åˆå§‹åŒ–éœæ…‹æ•¸æ“šç®¡ç†å™¨
            await staticDataManager.init();

            // ç”Ÿæˆè‚¡ç¥¨åˆ—è¡¨
            await renderStockList();

            // åˆå§‹åŒ–è‚¡ç¥¨é¸æ“‡å™¨
            const selector = $('#chart-symbol-selector');
            selector.empty();

            // æ·»åŠ æ‰€æœ‰å¯ç”¨çš„è‚¡ç¥¨æŒ‡æ•¸ï¼ˆåªé¡¯ç¤ºæœ‰æ•¸æ“šæ–‡ä»¶çš„æŒ‡æ•¸ï¼‰
            if (staticDataManager.indexData) {
                for (const symbol of Object.keys(staticDataManager.indexData)) {
                    const files = staticDataManager.indexData[symbol];
                    if (files && files.length > 0) {  // åªé¡¯ç¤ºæœ‰æ•¸æ“šæ–‡ä»¶çš„æŒ‡æ•¸
                        const marketInfo = staticDataManager.getMarketInfo(symbol);
                        selector.append(`<option value="${symbol}">${marketInfo.name}</option>`);
                    }
                }
            }

            $('#chart-symbol-selector').select2({
                placeholder: 'é¸æ“‡è‚¡ç¥¨',
                allowClear: true
            });

            // åˆå§‹åŒ–æ—¥æœŸé¸æ“‡å™¨
            initializeDatePickers();

            // åˆå§‹åŒ–ä¸‹è¼‰åŠŸèƒ½ä¸­çš„é¸æ“‡å™¨
            const indexSelector = $('#index_select');
            indexSelector.empty();
            indexSelector.append('<option value="">ä¸é¸æ“‡æŒ‡æ•¸</option>');

            const stockSelector = $('#stock_select');
            stockSelector.empty();

            const buildAllStocks = () => {
                const seen = new Set();
                const stocks = [];

                if (staticDataManager.indexStocks) {
                    for (const stockList of Object.values(staticDataManager.indexStocks)) {
                        if (!Array.isArray(stockList)) {
                            continue;
                        }
                        for (const stock of stockList) {
                            if (!seen.has(stock)) {
                                seen.add(stock);
                                stocks.push(stock);
                            }
                        }
                    }
                }

                return stocks.sort();
            };

            const refreshStockSelector = (targetIndex) => {
                stockSelector.empty();

                let stocks = [];

                if (targetIndex) {
                    stocks = staticDataManager.getStocksForIndex(targetIndex) || [];
                } else {
                    stocks = buildAllStocks();
                }

                if (!stocks || stocks.length === 0) {
                    stockSelector.append('<option value="" disabled>ç„¡å¯é¸è‚¡ç¥¨</option>');
                    stockSelector.prop('disabled', true);
                } else {
                    for (const stockSymbol of stocks) {
                        stockSelector.append(`<option value="${stockSymbol}">${stockSymbol}</option>`);
                    }
                    stockSelector.prop('disabled', false);
                }

                stockSelector.val(null);

                if (stockSelector.data('select2')) {
                    stockSelector.trigger('change.select2');
                } else {
                    stockSelector.trigger('change');
                }
            };

            if (staticDataManager.indexData) {
                const sortedIndices = Object.keys(staticDataManager.indexData)
                    .filter(symbol => {
                        const files = staticDataManager.indexData[symbol];
                        return files && files.length > 0;
                    })
                    .sort();

                for (const symbol of sortedIndices) {
                    const marketInfo = staticDataManager.getMarketInfo(symbol);
                    const label = marketInfo && marketInfo.name ? `${marketInfo.name} (${symbol})` : symbol;
                    indexSelector.append(`<option value="${symbol}">${label}</option>`);
                }
            }

            // é è¨­é¡¯ç¤ºå…¨éƒ¨å¯é¸è‚¡ç¥¨
            refreshStockSelector('');

            // åˆå§‹åŒ–Select2
            $('#stock_select').select2({
                placeholder: 'é¸æ“‡è‚¡ç¥¨ï¼ˆå¯å¤šé¸ï¼‰',
                allowClear: true
            });

            // é‡æ–°å¥—ç”¨ä¸€æ¬¡ä»¥æ›´æ–° Select2 ç‹€æ…‹
            refreshStockSelector(indexSelector.val());

            // ç•¶é¸æ“‡æŒ‡æ•¸æ™‚ï¼Œè‡ªå‹•é¸ä¸­è©²æŒ‡æ•¸çš„æ‰€æœ‰è‚¡ç¥¨
            $('#index_select').change(function() {
                const indexId = $(this).val();
                refreshStockSelector(indexId);
            });

            // è™•ç†ä¸‹è¼‰è¡¨å–®æäº¤
            $('#downloadForm').submit(async function(e) {
                e.preventDefault();

                const indexId = $('#index_select').val();
                const selectedStocks = $('#stock_select').val() || [];
                const startMonthValue = $('#start_month').val();
                const endMonthValue = $('#end_month').val();
                const trainWindowType = $('#train_window_type').val();
                const testWindowType = $('#test_window_type').val();

                if (!indexId && selectedStocks.length === 0) {
                    alert('è«‹é¸æ“‡è‡³å°‘ä¸€æ”¯è‚¡ç¥¨æˆ–ä¸€å€‹æŒ‡æ•¸');
                    return;
                }

                if (!startMonthValue || !endMonthValue) {
                    alert('è«‹é¸æ“‡å®Œæ•´çš„æœˆä»½å€é–“');
                    return;
                }

                if (startMonthValue > endMonthValue) {
                    alert('èµ·å§‹æœˆä»½ä¸èƒ½æ™šæ–¼çµæŸæœˆä»½');
                    return;
                }

                const startDate = new Date(`${startMonthValue}-01T00:00:00`);
                const [endYearStr, endMonthStr] = endMonthValue.split('-');
                const endYear = parseInt(endYearStr, 10);
                const endMonthIndex = parseInt(endMonthStr, 10) - 1;
                const endDate = new Date(endYear, endMonthIndex + 1, 0);

                if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) {
                    alert('æ—¥æœŸæ ¼å¼ä¸æ­£ç¢º');
                    return;
                }

                if (startDate > endDate) {
                    alert('èµ·å§‹æ—¥æœŸä¸èƒ½æ™šæ–¼çµæŸæ—¥æœŸ');
                    return;
                }

                try {
                    const { allStocks, stockToIndexMap } = staticDataManager.resolveStocksForDownload(indexId, selectedStocks);

                    if (allStocks.length === 0) {
                        alert('æ‰¾ä¸åˆ°å°æ‡‰çš„è‚¡ç¥¨è³‡æ–™');
                        return;
                    }

                    $('#downloadForm button[type="submit"]').prop('disabled', true).text('ç”Ÿæˆä¸­...');

                    const intervals = computeWindowIntervals(startDate, endDate, trainWindowType, testWindowType);

                    if (intervals.length === 0) {
                        alert('æŒ‡å®šçš„æ™‚é–“ç¯„åœå…§æ²’æœ‰å°æ‡‰çš„è¨“ç·´/æ¸¬è©¦å€é–“');
                        $('#downloadForm button[type="submit"]').prop('disabled', false).text('ä¸‹è¼‰Excel');
                        return;
                    }

                    const zip = new JSZip();
                    const groupedStocks = groupStocksByIndex(allStocks, stockToIndexMap);

                    for (const { indexSymbol, stocks } of groupedStocks) {
                        if (!staticDataManager.indexData || !staticDataManager.indexData[indexSymbol]) {
                            console.warn(`ç´¢å¼• ${indexSymbol} æ²’æœ‰è³‡æ–™æª”æ¡ˆ`);
                            continue;
                        }

                        const files = staticDataManager.getSortedFileList(indexSymbol);

                        if (!files || files.length === 0) {
                            console.warn(`ç´¢å¼• ${indexSymbol} æ²’æœ‰å¯ç”¨æª”æ¡ˆ`);
                            continue;
                        }

                        const dailyData = await loadAllDailyData(indexSymbol, stocks);

                        if (!dailyData || dailyData.size === 0) {
                            console.warn(`${indexSymbol} æ²’æœ‰è¼‰å…¥åˆ°ä»»ä½•æ•¸æ“š`);
                            continue;
                        }

                        for (const interval of intervals) {
                            const trainCsv = buildCsvForInterval(dailyData, stocks, interval.train.start, interval.train.end);
                            if (trainCsv) {
                                const filename = generateStaticFilename('train', indexSymbol, interval, trainWindowType, testWindowType);
                                zip.file(filename, trainCsv);
                            }

                            if (interval.test) {
                                const testCsv = buildCsvForInterval(dailyData, stocks, interval.test.start, interval.test.end);
                                if (testCsv) {
                                    const filename = generateStaticFilename('test', indexSymbol, interval, trainWindowType, testWindowType);
                                    zip.file(filename, testCsv);
                                }
                            }
                        }
                    }

                    const zipContent = await zip.generateAsync({ type: 'blob' });
                    const fileName = `stock_prices_${formatDateCompact(startDate)}_${formatDateCompact(endDate)}.zip`;
                    saveAs(zipContent, fileName);

                    $('#downloadForm button[type="submit"]').prop('disabled', false).text('ä¸‹è¼‰Excel');
                } catch (error) {
                    console.error('ç”Ÿæˆä¸‹è¼‰æª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    alert('ç”Ÿæˆä¸‹è¼‰æª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹æŸ¥çœ‹æ§åˆ¶å°ä»¥å–å¾—è©³ç´°è³‡è¨Šã€‚');
                    $('#downloadForm button[type="submit"]').prop('disabled', false).text('ä¸‹è¼‰Excel');
                }
            });

            // ç›£è½è¨“ç·´æœŸé•·åº¦çš„è®ŠåŒ–
            $('#train_window_type').change(function() {
                updateTestWindowOptions();
            });

            // åˆå§‹åŒ–æ¸¬è©¦æœŸé¸é …
            updateTestWindowOptions();

            // é è¨­é¸æ“‡ç¬¬ä¸€å€‹è‚¡ç¥¨
            const firstSymbol = $('#chart-symbol-selector option:first').val();
            if (firstSymbol) {
                $('#chart-symbol-selector').val([firstSymbol]).trigger('change');
                loadMultiTrendChart();
            }

            // ç›£è½æ—¥æœŸè®Šæ›´äº‹ä»¶
            $('#start-date').change(function() {
                const startDate = $(this).val();
                $('#end-date').attr('min', startDate);
            });

            $('#end-date').change(function() {
                const endDate = $(this).val();
                $('#start-date').attr('max', endDate);
            });

            $('#start_month').change(function() {
                const value = $(this).val();
                if (value) {
                    $('#end_month').attr('min', value);
                    const currentEnd = $('#end_month').val();
                    if (currentEnd && currentEnd < value) {
                        $('#end_month').val(value);
                    }
                }
            });
        });

        // ç›£è½æ›´æ–°æŒ‰éˆ•äº‹ä»¶
        $('#update-chart').click(function() {
            loadMultiTrendChart();
        });
    </script>
</body>
</html>